{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ad87df32",
   "metadata": {},
   "source": [
    "# One-dimensional (1D) Fourier transformation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "131908e3",
   "metadata": {},
   "source": [
    "In this notebook, we are going to transform time-domain data into 1D or 2D spectra using SpectroChemPy\n",
    "processing tools"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc1e4ec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import spectrochempy as scp"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d95f556",
   "metadata": {},
   "source": [
    "## FFT of 1D NMR spectra"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48acd964",
   "metadata": {},
   "source": [
    "First we open read some time domain data. Here is a NMD free induction decay (FID):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "39fd1b6a",
   "metadata": {},
   "outputs": [],
   "source": [
    "path = scp.preferences.datadir / \"nmrdata\" / \"bruker\" / \"tests\" / \"nmr\" / \"topspin_1d\"\n",
    "fid = scp.read_topspin(path)\n",
    "fid"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c651c58",
   "metadata": {},
   "source": [
    "The type of the data is complex:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "036883b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "fid.dtype"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8e7dd2c0",
   "metadata": {},
   "source": [
    "We can represent both real and imaginary parts on the same plot using the `show_complex` parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2faa1412",
   "metadata": {},
   "outputs": [],
   "source": [
    "prefs = fid.preferences\n",
    "prefs.figure.figsize = (6, 3)\n",
    "_ = fid.plot(show_complex=True, xlim=(0, 15000))\n",
    "print(\"td = \", fid.size)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f50ed16c",
   "metadata": {},
   "source": [
    "Now we perform a Fast Fourier Transform (FFT):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "315981af",
   "metadata": {},
   "outputs": [],
   "source": [
    "spec = scp.fft(fid)\n",
    "_ = spec.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec.size)\n",
    "spec"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee78fff5",
   "metadata": {},
   "source": [
    "**Alternative notation**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b9cb942",
   "metadata": {},
   "outputs": [],
   "source": [
    "k = 1024\n",
    "spec = fid.fft(size=32 * k)\n",
    "_ = spec.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d370d9c",
   "metadata": {},
   "outputs": [],
   "source": [
    "newfid = spec.ifft()\n",
    "# x coordinate is in second (base units) so lets transform it\n",
    "_ = newfid.plot(show_complex=True, xlim=(0, 15000))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "073c9f0c",
   "metadata": {},
   "source": [
    "Let's compare fid and newfid. There differs as a rephasing has been automatically applied after the first FFT (with\n",
    "the parameters found in the original fid metadata: PHC0 and PHC1).\n",
    "\n",
    "First point in the time domain of the real part is at the maximum."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "becf300b",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = newfid.real.plot(c=\"r\", label=\"fft + ifft\")\n",
    "ax = fid.real.plot(clear=False, xlim=(0, 5000), ls=\"--\", label=\"original real part\")\n",
    "_ = ax.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a3c4ea8a",
   "metadata": {},
   "source": [
    "First point in the time domain of the imaginary part is at the minimum."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b5e6d82",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = fid.imag.plot(ls=\"--\", label=\"original imaginary part\")\n",
    "ax = newfid.imag.plot(clear=False, xlim=(0, 5000), c=\"r\", label=\"fft + ifft\")\n",
    "_ = ax.legend(loc=\"lower right\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "af65773e",
   "metadata": {},
   "source": [
    "## Preprocessing\n",
    "\n",
    "### Line broadening\n",
    "Often before applying FFT, some exponential multiplication `em`or other broadening filters such as `gm` or `sp`\n",
    "are applied.\n",
    "See the dedicated [apodization tutorial](apodization.ipynb)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ec0901f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "fid2 = fid.em(lb=\"50. Hz\")\n",
    "spec2 = fid2.fft()\n",
    "_ = spec2.plot()\n",
    "_ = spec.plot(\n",
    "    clear=False, xlim=(10, -5), c=\"r\"\n",
    ")  # superpose the non broadened spectrum in red and show expansion."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c295ddde",
   "metadata": {},
   "source": [
    "### Zero-filling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "979145e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"td = \", fid.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e24098ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "td = 64 * 1024  # size: 64 K\n",
    "fid3 = fid.zf_size(size=td)\n",
    "print(\"new td = \", fid3.x.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90ebc895",
   "metadata": {},
   "outputs": [],
   "source": [
    "spec3 = fid3.fft()\n",
    "_ = spec3.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec3.size)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bca1adb6",
   "metadata": {},
   "source": [
    "### Time domain baseline correction\n",
    "See the dedicated [Time domain baseline correction tutorial](td_baseline.ipynb)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5456239d",
   "metadata": {},
   "source": [
    "### Magnitude calculation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c8730794",
   "metadata": {},
   "outputs": [],
   "source": [
    "ms = spec.mc()\n",
    "_ = ms.plot(xlim=(10, -10))\n",
    "_ = spec.plot(clear=False, xlim=(10, -10), c=\"r\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d0f9c09",
   "metadata": {},
   "source": [
    "### Power spectrum"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0fffa3d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "mp = spec.ps()\n",
    "_ = (mp / mp.max()).plot()\n",
    "_ = (spec / spec.max()).plot(\n",
    "    clear=False, xlim=(10, -10), c=\"r\"\n",
    ")  # Here we have normalized the spectra at their max value."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4802bbc",
   "metadata": {},
   "source": [
    "# Real Fourier transform"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08f33d1d",
   "metadata": {},
   "source": [
    "In some case, it might be interesting to perform real Fourier transform . For instance, as a demonstration,\n",
    "we will independently transform real and imaginary part of the previous fid, and recombine them to obtain the same\n",
    "result as when performing complex fourier transform on the complex dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "460f2ff0",
   "metadata": {},
   "outputs": [],
   "source": [
    "lim = (-20, 20)\n",
    "_ = spec3.plot(xlim=lim)\n",
    "_ = spec3.imag.plot(xlim=lim)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f07bbf1",
   "metadata": {},
   "outputs": [],
   "source": [
    "Re = fid3.real.astype(\"complex64\")\n",
    "fR = Re.fft()\n",
    "_ = fR.plot(xlim=lim, show_complex=True)\n",
    "Im = fid3.imag.astype(\"complex64\")\n",
    "fI = Im.fft()\n",
    "_ = fI.plot(xlim=lim, show_complex=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b600c72e",
   "metadata": {},
   "source": [
    "Recombination:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f8d7dc01",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = (fR - fI.imag).plot(xlim=lim)\n",
    "_ = (fR.imag + fI).plot(xlim=lim)"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "title,-all",
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.1"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
